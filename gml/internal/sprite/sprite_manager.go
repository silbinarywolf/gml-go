package sprite

import (
	"bytes"
	"encoding/gob"
	"errors"
	"io/ioutil"

	"github.com/silbinarywolf/gml-go/gml/internal/file"
)

const (
	SpriteDirectoryBase = "sprite"
)

var (
	gSpriteManager = newSpriteManager()
)

type spriteManager struct {
	assetList        []Sprite
	assetNameToIndex map[string]SpriteIndex
	assetIndexToName []string
}

func newSpriteManager() *spriteManager {
	manager := &spriteManager{}
	return manager
}

// InitSpriteGeneratedData is used by code generated by gmlgo so you can query a sprite by index or name
func InitSpriteGeneratedData(indexToName []string, nameToIndex map[string]SpriteIndex) {
	gSpriteManager.assetIndexToName = indexToName
	gSpriteManager.assetNameToIndex = nameToIndex
	gSpriteManager.assetList = make([]Sprite, len(gSpriteManager.assetIndexToName))

	// todo(Jake): 2018-12-19 -
	// Improve by loading concurrently in Go routine?
	// Pack into 1 or chunked data files?
	for _, spriteIndex := range nameToIndex {
		SpriteLoad(spriteIndex)
	}
}

func SpriteNames() []string {
	return gSpriteManager.assetIndexToName
}

func sprite(index SpriteIndex) *Sprite {
	sprite := &gSpriteManager.assetList[index]
	if sprite.isLoaded() {
		return sprite
	}
	return nil
}

// SpriteLoadByName is used internally by the room editor, animation editor,
// live-sprite reloading watcher and more
func SpriteLoadByName(name string) SpriteIndex {
	index, ok := gSpriteManager.assetNameToIndex[name]
	if !ok {
		return SprUndefined
	}
	SpriteLoad(index)
	return index
}

/*func SpriteSize(index SpriteIndex) geom.Size {
	manager := gSpriteManager
	sprite := &manager.assetList[index]
	if !sprite.isUsed() {
		panic("sprite: Invalid sprite.")
	}
	return sprite.Size()
}*/

func SpriteLoad(index SpriteIndex) {
	manager := gSpriteManager
	sprite := &manager.assetList[index]
	if sprite.isLoaded() {
		return
	}
	name := manager.assetIndexToName[index]
	// todo(Jake): change loadSprite() to return Sprite, not *Sprite
	result := loadSprite(name)
	*sprite = *result
}

func loadSpriteFromData(name string) *spriteAsset {
	path := file.AssetDirectory + "/" + SpriteDirectoryBase + "/" + name + ".data"
	fileData, err := file.OpenFile(path)
	if err != nil {
		//panic(errors.New("Unable to find image: " + path))
		return nil
	}
	bytesData, err := ioutil.ReadAll(fileData)
	fileData.Close()
	if err != nil {
		panic(errors.New("Unable to read bytes from image: " + path))
	}
	buf := bytes.NewReader(bytesData)
	asset := new(spriteAsset)
	gob.NewDecoder(buf).Decode(asset)
	return asset
}

func loadSprite(name string) *Sprite {
	// If debug mode, write out the sprite to *.data file
	debugWriteSprite(name)

	// Load from *.data
	spriteAsset := loadSpriteFromData(name)
	if spriteAsset == nil {
		panic("Unable to load sprite from data file: " + name)
	}
	frames := make([]SpriteFrame, len(spriteAsset.Frames))
	for i := 0; i < len(spriteAsset.Frames); i++ {
		frameAsset := spriteAsset.Frames[i]
		frame, err := createFrame(frameAsset)
		if err != nil {
			panic("Sprite frame load error for \"" + name + "\": " + err.Error())
		}
		frames[i] = frame
	}

	// Create sprite
	result := newSprite(spriteAsset.Name, frames, spriteConfig{
		ImageSpeed: spriteAsset.ImageSpeed,
	})
	return result
}
